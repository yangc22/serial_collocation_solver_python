// Created by OCP.py
#include <stdio.h>
#include <float.h>
#include <math.h>
#include <stdlib.h>
#include "runtime.h"
#include "vector.h"
#include "matrix.h"
#include "lu.h"
#include "qr.h"
#include "abd.h"
#include "equations.h"
#include "newtonsmethod.h"
#include "abvpdae.h"
#include "mshootdae.h"

double _rho_ = 1.0e3;

double _mu_ = 1.0e-1;


def _abvp_f(self, _y, _z, _p, _f):
	x1 = _y[0]
	x2 = _y[1]
	_lambda1 = _y[2]
	_lambda2 = _y[3]
	u1 = _z[0]
	_f[0] = x2
	_f[1] = u1
	_f[2] = 0
	_f[3] = -_lambda1


def _abvp_g(self, _y, _z, _p, _g):
	x1 = _y[0]
	x2 = _y[1]
	_lambda1 = _y[2]
	_lambda2 = _y[3]
	u1 = _z[0]
	_g[0] = _lambda2 + 1.0*u1


def _abvp_r(self, _y0, _y1, _p, _r):
	_kappa_i1 = _p[0]
	_kappa_i2 = _p[1]
	_kappa_f1 = _p[2]
	_kappa_f2 = _p[3]
	x1 = _y0[0]
	x2 = _y0[1]
	_lambda1 = _y0[2]
	_lambda2 = _y0[3]
	# initial conditions
	_r[0] = x1 - 1.0
	_r[1] = x2 - 1.0
	_r[2] = _kappa_i1 + _lambda1
	_r[3] = _kappa_i2 + _lambda2
	# final conditions
	x1 = _y1[0]
	x2 = _y1[1]
	_lambda1 = _y1[2]
	_lambda2 = _y1[3]
	_r[4] = x1
	_r[5] = x2
	_r[6] = -_kappa_f1 + _lambda1
	_r[7] = -_kappa_f2 + _lambda2


def _abvp_Df(self, _y, _z, _p, _Df):
	x1 = _y[0]
	x2 = _y[1]
	_lambda1 = _y[2]
	_lambda2 = _y[3]
	u1 = _z[0]
	_Df[0][1] = 1
	_Df[1][4] = 1
	_Df[3][2] = -1


def _abvp_Dg(self, _y, _z, _p, _Dg):
	x1 = _y[0]
	x2 = _y[1]
	_lambda1 = _y[2]
	_lambda2 = _y[3]
	u1 = _z[0]
	_Dg[0][3] = 1
	_Dg[0][4] = 1.00000000000000


def _abvp_Dr(self, _y0, _y1, _p, _Dr):
	_kappa_i1 = _p[0]
	_kappa_i2 = _p[1]
	_kappa_f1 = _p[2]
	_kappa_f2 = _p[3]
	x1 = _y0[0]
	x2 = _y0[1]
	_lambda1 = _y0[2]
	_lambda2 = _y0[3]
	# initial conditions
	_Dr[0][0] = 1
	_Dr[1][1] = 1
	_Dr[2][2] = 1
	_Dr[2][8] = 1
	_Dr[3][3] = 1
	_Dr[3][9] = 1
	# final conditions
	x1 = _y1[0]
	x2 = _y1[1]
	_lambda1 = _y1[2]
	_lambda2 = _y1[3]
	_Dr[4][4] = 1
	_Dr[5][5] = 1
	_Dr[6][6] = 1
	_Dr[6][10] = -1
	_Dr[7][7] = 1
	_Dr[7][11] = -1


int main() {
	int _ny = 4;
	int _nz = 1;
	int _np = 4;
	int _ninequality = 0;
	ABVPDAE _bvp = ABVPDAENew(_ny, _nz, _np, _ninequality);
	_bvp->f = _abvp_f;
	_bvp->g = _abvp_g;
	_bvp->r = _abvp_r;
	_bvp->Df = _abvp_Df;
	_bvp->Dg = _abvp_Dg;
	_bvp->Dr = _abvp_Dr;
	MSHOOTDAE _m = MSHOOTDAENew();
	_m->bvp = _bvp;
	_m->tolerance = 1e-06;
	_m->maximum_nodes = 1000;
	_m->maximum_newton_iterations = 200;
	_m->maximum_mesh_refinements = 10;
	_m->display = 1;
	int _N = 101;
	double _t_initial = 0;
	double _t_final = 1;
	Vector _T0 = VectorLinspace(_t_initial, _t_final, _N);
	Matrix _Y0 = MatrixNew(_N, _ny);
	Matrix _Z0 = MatrixNew(_N, _nz);
	Vector _P0 = VectorNew(_np);
	MatrixSetAllTo(_Y0, 1.0);
	MatrixSetAllTo(_Z0, 1.0);
	VectorSetAllTo(_P0, 1.0);
	int _err = MSHOOTDAESolve(_m, _T0, _Y0, _Z0, _P0);
	printf("MSHOOTDAESolve exit code: %d\n", _err);
	_err = MSHOOTDAEWriteData(_m, "ex2.data");
	ABVPDAEDelete(_bvp);
	MSHOOTDAEDelete(_m);
	VectorDelete(_T0);
	MatrixDelete(_Y0);
	MatrixDelete(_Z0);
	VectorDelete(_P0);
	return _err;
}

/*

# Sage, A. P. and White, C. C., Optimum Systems Control,
# Prentice-Hall, 1977.

StateVariables 			= [x1, x2];
ControlVariables 		= [u1];
InitialConstraints 		= [x1 - 1.0, x2 - 1.0];
TerminalConstraints 	= [x1, x2];
CostFunctional 			= u1*u1*0.5;
#TerminalPenalty         = x1*x1;
DifferentialEquations 	= [x2, u1];
Nodes					= 101;
Tolerance				= 1.0e-6;
OutputFile				= "ex2.data";
Display					= YES;

*/

